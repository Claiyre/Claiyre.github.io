webpackJsonp([17,20],{776:function(n,o){n.exports={content:'<div class="picidae-toc">\n<ul>\n<li>\n<a href="#%E5%89%8D%E8%A8%80">前言</a>\n</li>\n<li>\n<a href="#%E6%AD%A3%E6%96%87">正文</a>\n<ul>\n<li>\n<ul>\n<li>\n<a href="#%E6%B5%85%E5%A4%8D%E5%88%B6">浅复制</a>\n</li>\n<li>\n<a href="#%E6%B7%B1%E5%A4%8D%E5%88%B6">深复制</a>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<a href="#%E7%BB%93%E8%AF%AD">结语</a>\n</li>\n</ul>\n</div>\n<blockquote>\n<p>博客原文地址：<a href="https://claiyre.github.io/">Claiyre的个人博客 https://claiyre.github.io/</a>\n博客园地址：<a href="http://www.cnblogs.com/nuannuan7362/">http://www.cnblogs.com/nuannuan7362/</a>\n如需转载，请在文章开头注明原文地址</p>\n</blockquote>\n<h1 id="前言"><a href="#%E5%89%8D%E8%A8%80" aria-hidden="true"><span class="icon icon-link"></span></a>前言</h1>\n<p>从层次上来看，对象的复制可以简单地分为浅复制和深复制，顾名思义，浅复制是指只复制一层对象的属性，不会复制对象中的对象的属性，对象的深复制会复制对象中层层嵌套的对象的属性。\n在复制对象时，除了要复制对象的属性外，还要兼顾到是否保留了对象的constructor属性，是否对每一种数据类型（JavaScript常见的数据类型有String，Number，Boolean,Data,RegExp,Array,Funtion,Object）都实现正确的复制。项目中，我们可以根据实际情况，决定需要实现什么样程度的复制。\n本文是我在复制对象方面的一些心得总结，由浅复制到深复制，由只复制简单属性到复制Function，RegExp等复杂属性，层层递进。如有陈述不当之处，烦请指出，不胜感激。</p>\n<!--more-->\n<h1 id="正文"><a href="#%E6%AD%A3%E6%96%87" aria-hidden="true"><span class="icon icon-link"></span></a>正文</h1>\n<h3 id="浅复制"><a href="#%E6%B5%85%E5%A4%8D%E5%88%B6" aria-hidden="true"><span class="icon icon-link"></span></a>浅复制</h3>\n<p>浅复制只会依次复制对象的每一个属性，不会对这些属性进行递归复制。下面是一个简单的浅复制实现。</p>\n<pre><code data-query="{}" data-lang="">//对象浅复制                                                           \nfunction shadowCopy(obj){\n        if(typeof obj !== \'object\' || obj === null)  return obj ;\n\n        for(var prop in obj){\n            if(obj.hasOwnProperty(prop)){\n                newObj[prop] = obj[prop];\n            }\n        }\n        return newObj;\n    }\n</code></pre>\n<p>仔细观察，不难发现上述方法的缺陷：\n1.不能正确实现数组的浅复制\n2.复制操作丢失了对象的constructor属性</p>\n<p>好，我们现在已经发现了问题所在，只需针对性地解决，一个还算完美的浅复制对象的方法就诞生了！</p>\n<pre><code data-query="{}" data-lang="">//对象浅复制\n    function shadowCopy(obj){\n            if(typeof obj !== \'object\' || obj === null)  return obj ;\n            var newObj;\n\n            //保留对象的constructor属性\n            if(obj.constructor === Array){\n                newObj = [];\n            } else {\n                newObj = {};\n                newObj.constructor = obj.constructor;\n            }\n\n            for(var prop in obj){\n                if(obj.hasOwnProperty(prop)){\n                    newObj[prop] = obj[prop];\n                }\n            }\n            return newObj;\n        }\n</code></pre>\n<p>浏览器中测试一下：</p>\n<pre><code data-query="{}" data-lang="">    var arr1 = [0,1,2];\n    console.log(arr1);\n    console.log(shadowCopy(arr1));\n    \n    var arr2 = [0,1,2,[3,4,5]],\n        arr2Copy = shadowCopy(arr2);\n    console.log(arr2);\n    console.log(arr2Copy);\n    arr2Copy[3][0] = 6;\n    console.log(arr2[3][0]);  //6\n</code></pre>\n<p><img src="http://i4.buimg.com/567571/577c9855b9bf0430.png"></p>\n<p>Good! 可以正确实现数组复制和并且保留constructor了，但细心的你一定发现了，浅复制后的对象的 <code>arr2Copy[3]</code> 和 <code>arr2[3]</code> 指向的是一个对象，改变其中一个，同时也会改变另一个。我们想要实现的是 <strong>复制</strong>，但这并不是复制呀！\n这是浅复制的一个弊端所在，接下让我们看看深复制是怎样解决这个问题的。</p>\n<h3 id="深复制"><a href="#%E6%B7%B1%E5%A4%8D%E5%88%B6" aria-hidden="true"><span class="icon icon-link"></span></a>深复制</h3>\n<p>深复制需要层层递归，复制对象的所有属性，包括对象属性的属性的属性....(晕~)\n如果只是需要简单地复制对象的属性，而不用考虑它的constructor，也不用考虑函数，正则，Data等特殊数据类型，那这里有一个深复制的小trick，两行代码即可：</p>\n<pre><code data-query="{}" data-lang="">function deepCopy(obj){\n    if(typeof obj !== \'object\' || obj === null)  return obj ;\n    var str = JSON.stringify(obj);\n\n    return JSON.parse(str);\n}\n</code></pre>\n<p>大多数情况下，上面的就可以满足要求了，但一些时候，我们需要把函数，正则等特殊数据类型也考虑在内，或者当前环境不支持JSON时，上面的方法也就不适用了。这时，我们可以通过递归来实现对象的深层复制，如下：</p>\n<pre><code data-query="{}" data-lang="">function deepCopy(obj){\n    if(typeof obj !== \'object\' || obj === null)  return obj ;\n    var newObj;\n\n    //保留对象的constructor属性\n    if(obj.constructor === Array){\n        newObj = [];\n    } else {\n        newObj = {};\n        newObj.constructor = obj.constructor;\n    }\n\n    for(var prop in obj){\n        if(typeof obj[prop] === \'object\'){\n            if(obj[prop].constructor === RegExp ||obj[prop].constructor === Date){\n                newObj[prop] = obj[prop];\n            } else {\n                //递归\n                newObj[prop] = deepCopy(obj[prop]);\n            }\n        } else {\n            newObj[prop] = obj[prop];\n        }\n    }\n    return newObj;\n}\n</code></pre>\n<p>先用上面的例子测试：</p>\n<p><img src="http://i1.piimg.com/567571/e86a7c0b5191a6b1.png"></p>\n<p>棒！可以正确实现多维数组的<strong>复制</strong>，再看是否能实现函数和正则的复制：</p>\n<pre><code data-query="{}" data-lang="">function Person(name){\n    this.name = name;\n    this.age = age;\n    this.search = new RegExp(name);\n    this.say = function(){\n        console.log(this.name + "今年" + this.age + "岁了");\n    }\n}\nvar p1 = new Person("Claiyre",20),\n    p2 = deepCopy(p1);\n\nconsole.log(p1);\nconsole.log(p2);\n\np2.age = 22;\np1.say();\np2.say();\n</code></pre>\n<p><img src="http://i2.muimg.com/567571/2b2b14b3ad818535.png"></p>\n<p>圆满完成！！</p>\n<p>稍加整理，我们就可以得到一个较为通用的js对象复制函数：</p>\n<pre><code data-query="{}" data-lang="">function deepCopy(obj){\n    if(typeof obj !== \'object\' || obj === null)  return obj ;\n\n    var newObj = obj.constructor === Array ? []:{};\n    newObj.constructor = obj.constructor;\n\n    if(window.JSON){\n        //若需要考虑特殊的数据类型，如正则，函数等，把这个if去掉直接进入else内容即可\n        newObj = JSON.parse(JSON.stringify(obj));\n    } else {\n        for(var prop in obj){\n            if(obj[prop].constructor === RegExp ||obj[prop].constructor === Date){\n                newObj[prop] = obj[prop];\n            } else if(typeof obj[prop] === \'object\'){\n                //递归\n                newObj[prop] = deepCopy(obj[prop]);\n            } else {\n                newObj[prop] = obj[prop];\n            }\n        }\n    } \n    return newObj;\n}\n</code></pre>\n<h1 id="结语"><a href="#%E7%BB%93%E8%AF%AD" aria-hidden="true"><span class="icon icon-link"></span></a>结语</h1>\n<p>面向对象的编程语言，其核心是对象，因此深入了解对象的相关操作，纵向比较异同，对学习过程是极有好处的。</p>\n',extra:{}}}});