webpackJsonp([18,20],{775:function(n,e){n.exports={content:'<div class="picidae-toc">\n<ul>\n<li>\n<a href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96">普通函数定义与初始化</a>\n</li>\n<li>\n<a href="#generator%EF%BC%88%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">generator（生成器）函数的定义</a>\n<ul>\n<li>\n<a href="#%E7%BA%B8%E4%B8%8A%E8%B0%88%E5%85%B5%E7%BB%88%E8%A7%89%E6%B5%85%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90">纸上谈兵终觉浅，我们来看一个例子</a>\n</li>\n</ul>\n</li>\n<li>\n<a href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">箭头函数的定义</a>\n</li>\n</ul>\n</div>\n<p>在许多传统的OO语言中，对象可以包含数据，还可拥有方法，也就是属于该对象的函数。但在JavaScript中，函数也被认为是一个对象，一个Function对象，因此函数被称为JavaScript的<code>一级公民</code>（ first-class objects）！</p>\n<!--more-->\n<blockquote>\n<p>博客原文地址：<a href="https://claiyre.github.io/">Claiyre的个人博客</a>\n如需转载，请在文章开头注明原文地址</p>\n</blockquote>\n<h3 id="普通函数定义与初始化"><a href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96" aria-hidden="true"><span class="icon icon-link"></span></a>普通函数定义与初始化</h3>\n<p>1.通过构造器Function\n我们知道，JavaScript中Array，Date等基本类型的声明是通过其对应的构造器（关键字）来声明的。如</p>\n<pre><code data-query="{}" data-lang="">var arr1 = new Array();   #声明一个空数组\nvar date1 = new Date();   #声明一个时间对象，获取当前时间\n</code></pre>\n<p>与定义其他基本对象类型如Array，Date一样，JavaScript的函数是通过关键字Function来定义并初始化的</p>\n<pre><code data-query="{}" data-lang=""> new Function([arg1],[arg2](,[arg3,...]),functionBody);\n</code></pre>\n<p>举个栗子</p>\n<pre><code data-query="{}" data-lang="">var f1 = new Function(\'name\',\'age\',\'console.log("hello," + name);console.log("You are " + age)\');\nf1("Claiyre",20);\n</code></pre>\n<p>当然，除了这种‘吃力不讨好’的定义方法外，你还有其他更简洁的方法来定义一个函数！</p>\n<p>2.通过函数声明（function statement）\n语法：</p>\n<pre><code data-query="{}" data-lang="">function name([arg1,[,arg2,[...argn]]]) {\n   functionBody;\n }\n</code></pre>\n<p> name是指定的函数名，arg是函数的参数，可以为任意多个（当然，不能超过可以表示的范围），functionBody为函数体。\n栗子如下</p>\n<pre><code data-query="{}" data-lang="">function sayHi (name,age){\n       console.log("hello," + name);\n       console.log("you are " + age);\n }\n</code></pre>\n<p>3.通过函数表达式（function expression)\n语法</p>\n<pre><code data-query="{}" data-lang="">   function [name]([arg1,[,arg2,[...argn]]]) {\n       console.log("hello," + name);\n       console.log("you are " + age);\n   }\n</code></pre>\n<p>4.总结</p>\n<ul>\n<li>方式2和方式3拥有几乎相同的语法，极其相似。但聪明的你一定发现了它们的不同之处了对不对O(∩_∩)O——函数表达式定义一个函数时可以省略函数名，从而创建一个匿名函数或一个立即执行函数(IIFE)。</li>\n<li>相比于方式2和方式3，方式1用Function构造器声明函数的方式更为低效，因为后者生成的对象是在函数被创建时解析的，前者是和其他代码一起解析的。</li>\n<li>通过函数调用的方式调用Function 的构造函数（不用new关键字）跟方式1是一样的</li>\n<li>使用Function构造器，并不会在创建它的上下文(Context)中创建闭包，所以它们只能访问自身局部变量和全局变量，相当于它们总是在全局作用域中被创建的，即便实际并不是！</li>\n</ul>\n<pre><code data-query="{}" data-lang="">myName = \'outer\';\nvar person = {\n                myName: \'inner\',\n                sayHi: new Function(\'like\',\'console.log("I am "+ myName + "!I like " + like)\')\n            };\n person.sayHi("banana");\n</code></pre>\n<p>结果如下：\n<img src="http://p1.bpimg.com/567571/e00ccdd2bd6a618c.png"></p>\n<h3 id="generator（生成器）函数的定义"><a href="#generator%EF%BC%88%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89" aria-hidden="true"><span class="icon icon-link"></span></a>generator（生成器）函数的定义</h3>\n<p>generator是ES6标准引入的新的数据类型，旨在利用生成器函数返回一个对象，该对象遵守迭代器协议，而generator的环境(context)在每次执行后都会被保存，以便迭代器对象再次使用，每次迭代就相当于生成一个新的函数，这也是命名为generator（函数生成器）的缘故吧。迭代器协议是ES6标准引入的新协议之一，具体参见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator">the iterable protocol</a></p>\n<p>与普通函数类似，generator函数也有三种定义方式，但与普通函数稍有不同，具体如下\n1. 通过GeneratorFunction构造器</p>\n<pre><code data-query="{}" data-lang="">    new GeneratorFunction ([arg1[, arg2[, ...argN]],] functionBody)\n</code></pre>\n<ol start="2">\n<li>通过function<em> 声明（function</em> statement）</li>\n</ol>\n<pre><code data-query="{}" data-lang="">    function* name([param[, param[, ... param]]]) {\n         statements\n     }\n</code></pre>\n<ol start="3">\n<li>通过function<em>表达式（function</em> expression）</li>\n</ol>\n<pre><code data-query="{}" data-lang="">    function* [name]([param1[, param2[, ..., paramN]]]) {\n       statements\n    }\n</code></pre>\n<p>调用一个生成器函数并不会立即执行它的主体，而是返回一个与该函数对应的迭代器对象，当调用这个迭代器对象的<strong>next()</strong>方法时，生成器函数的主体才会被执行，直到遇见第一个 <strong>yield表达式</strong></p>\n<h4 id="纸上谈兵终觉浅，我们来看一个例子"><a href="#%E7%BA%B8%E4%B8%8A%E8%B0%88%E5%85%B5%E7%BB%88%E8%A7%89%E6%B5%85%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90" aria-hidden="true"><span class="icon icon-link"></span></a>纸上谈兵终觉浅，我们来看一个例子</h4>\n<pre><code data-query="{}" data-lang="">function* idMaker(){\n  var index = 0;\n  while(index &#x3C; 3)\n    yield index++;\n}\n\nvar gen = idMaker();   // 此时并没有执行idmaker的主体\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // undefined\n</code></pre>\n<p>即可用<strong>yield</strong>指定要返回的值，也可用 <strong>yield*</strong> 委派另一个generator函数对象  </p>\n<p>如下</p>\n<pre><code data-query="{}" data-lang="">function* generatorOne(index){                                                 \n   yield index;\n   yield* generatorTwo(index);\n   yield index+10;\n}\n\n function* generatorTwo(index){\n   yield index+1;\n   yield index+2;\n   yield index+3;\n}\n\nvar ge = generatorOne(10);                                                                \nconsole.log(ge.next());   \nconsole.log(ge.next());\nconsole.log(ge.next());\nconsole.log(ge.next());\nconsole.log(ge.next());\nconsole.log(ge.next());\n</code></pre>\n<p>运行结果如下：\n<img src="http://p1.bpimg.com/567571/0b42a32b3df47f38.png"></p>\n<p>我们可以看到<strong>ge.next()</strong>返回了一个对象，该对象有两个属性，value是其返回的值，done代表迭代器是否迭代到了尽头</p>\n<p>generator就像是一个不用占用任何全局变量就可以记住执行状态的函数，它的好处当然不只是上面例子那样简单，关于优点和用处，个人认为廖雪峰老师写的已相当不错，参见<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143450083887673122b45a4414333ac366c3c935125e7000">generator</a>  </p>\n<h3 id="箭头函数的定义"><a href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89" aria-hidden="true"><span class="icon icon-link"></span></a>箭头函数的定义</h3>\n<p>ES6标准有一个深受广大程序猿喜爱的新属性，那就是箭头函数。它的定义就是用一个箭头。其具体语法如下</p>\n<pre><code data-query="{}" data-lang="">let add = x => x+1 ;\nadd(10);   //11\n</code></pre>\n<p>是不是很简便呢？</p>\n<p>当然如果有多个参数的话，需要给所有参数加上括号</p>\n<pre><code data-query="{}" data-lang="">let add = (x,y) => x+y ;\nadd(5,6);\n</code></pre>\n<p>以此类推，如果函数体有多条语句的话，也应该给函数体加上<strong>{}</strong>\n此外，箭头函数的另一个特殊之处是它的this总是指向词法作用域，不能被改变,比如：</p>\n<pre><code data-query="{}" data-lang="">var myName = "outer";\nvar person = {\n    myName:"inner",\n    age:20\n};\nvar sayHi= ()=>console.log(this.myName);\nsayHi();                                  //outer\nsayHi.call(person);                       //outer\n</code></pre>\n<p>参考资料：\n<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions">MDN JavaScript</a></p>\n',extra:{}}}});