webpackJsonp([0,20],{793:function(n,e){n.exports={content:'<div class="picidae-toc">\n<ul>\n<li>\n<a href="#%E6%AD%A3%E6%96%87">正文</a>\n<ul>\n<li>\n<ul>\n<li>\n<a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AE%89%E5%85%A8%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">作用域安全的构造函数</a>\n</li>\n<li>\n<a href="#%E6%83%B0%E6%80%A7%E8%BD%BD%E5%85%A5%E5%87%BD%E6%95%B0">惰性载入函数</a>\n</li>\n<li>\n<a href="#%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F">函数绑定作用域</a>\n</li>\n<li>\n<a href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96curry">函数柯里化(curry)</a>\n</li>\n<li>\n<a href="#debounce%E5%87%BD%E6%95%B0">debounce函数</a>\n</li>\n<li>\n<a href="#once%E5%87%BD%E6%95%B0">once函数</a>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<a href="#%E7%BB%93%E8%AF%AD">结语</a>\n</li>\n</ul>\n</div>\n<blockquote>\n<p>博客原文地址：<a href="https://claiyre.github.io/">Claiyre的个人博客</a>\n如需转载，请在文章开头注明原文地址</p>\n</blockquote>\n<p>在JavaScript中，函数的功能十分强大。它们是第一类对象，也可以作为另一个对象的方法，还可以作为参数传入另一个函数，不仅如此，还能被一个函数返回！可以说，在JS中，函数无处不在，无所不能，堪比孙猴子呀！当你运用好函数时，它能助你取西经，让代码变得优雅简洁，运用不好时，那就遭殃了，要大闹天宫咯~\n除了函数相关的基础知识外，掌握一些高级函数并应用起来，不仅能让JS代码看起来更为精简，还可以提升性能。以下是博主总结的一些常用的、重要的高级函数，加上了一些个人见解，特此记录下来。如果您是JS初学者，也不要被“高级”两个字吓到，因为文中穿插讲解了一些原型、this等基础知识，相信并不难理解。如果您是JS大牛，也可以把本文用来查漏补缺。</p>\n<!--more-->\n<h1 id="正文"><a href="#%E6%AD%A3%E6%96%87" aria-hidden="true"><span class="icon icon-link"></span></a>正文</h1>\n<h3 id="作用域安全的构造函数"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AE%89%E5%85%A8%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="icon icon-link"></span></a>作用域安全的构造函数</h3>\n<pre><code data-query="{}" data-lang="">function Person(name,age){\n    this.name = name;\n    this.age = age;\n}\nvar p1 = new Person("Claiyre",80);\n</code></pre>\n<p>相信您对上面的构造函数一定不陌生，但是，，如果某个粗心的程序猿调用这个构造函数时忘记加<code>new</code>了会发生什么？</p>\n<pre><code data-query="{}" data-lang="">var p3 = Person("Tom",30);\nconsole.log(p3);              //undefined\nconsole.log(window.name);     //Tom\n</code></pre>\n<p>由于使用了不安全的构造函数，上面的代码意外的改变了window的name，因为<code>this</code>对象是在运行时绑定的，使用new调用构造函数时<code>this</code>是指向新创建的对象的，不使用<code>new</code>时，<code>this</code>是指向window的。\n由于window的name属性是用来识别链接目标和frame的，所在这里对该属性的偶然覆盖可能导致其他错误。</p>\n<p>作用域安全的构造函数会首先确认<code>this</code>对象是正确类型的实例，然后再进行更改，如下：</p>\n<pre><code data-query="{}" data-lang="">function Person(name,age){\n    if(this instanceof Person){\n        this.name = name;\n        this.age = age;\n    } else {\n        return new Person(name,age);\n    }   \n}\n</code></pre>\n<p>这样就避免了在全局对象上意外更改或设置属性。\n实现这个安全模式，相当于锁定了调用构造函数的环境，因此借用构造函数继承模式可能会出现问题，解决方法是组合使用原型链和构造函数模式，即组合继承。\n如果您是一个JS库或框架的开发者，相信作用域安全的构造函数一定对您非常有用。在多人协作的项目中，为了避免他们误改了全局对象，也应使用作用域安全的构造函数。</p>\n<h3 id="惰性载入函数"><a href="#%E6%83%B0%E6%80%A7%E8%BD%BD%E5%85%A5%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="icon icon-link"></span></a>惰性载入函数</h3>\n<p>由于浏览器间的行为差异，代码中可能会有许多检测浏览器行为的if语句。但用户的浏览器若支持某一特性，便会一直支持，所以这些if语句，只用被执行一次，即便只有一个if语句的代码，也比没有要快。\n惰性载入表示函数执行的分支仅会执行一次，有两种实现惰性载入的方式，第一种就是在函数第一次被调用时再处理函数，用检测到的结果重写原函数。</p>\n<pre><code data-query="{}" data-lang="">function detection(){\n    if(//支持某特性){\n        detection = function(){\n            //直接用支持的特性\n        }\n    } else if(//支持第二种特性){\n        detection = function(){\n            //用第二种特性\n        }\n    } else {\n        detection = function(){\n            //用其他解决方案\n        }\n    }\n}\n</code></pre>\n<p>第二种实现惰性载入的方式是在声明函数时就指定适当的函数</p>\n<pre><code data-query="{}" data-lang="">var detection = (function(){\n    if(//支持某特性){\n        return function(){\n            //直接用支持的特性\n        }\n    } else if(//支持第二种特性){\n        return function(){\n            //用第二种特性\n        }\n    } else {\n        return function(){\n            //用其他解决方案\n        }\n    } \n})();\n</code></pre>\n<p>惰性载入函数的有点是在只初次执行时牺牲一点性能，之后便不会再有多余的消耗性能。</p>\n<h3 id="函数绑定作用域"><a href="#%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F" aria-hidden="true"><span class="icon icon-link"></span></a>函数绑定作用域</h3>\n<p>在JS中，函数的作用域是在函数被调用时动态绑定的，也就是说函数的this对象的指向是不定的，但在一些情况下，我们需要让某一函数的执行作用域固定，总是指向某一对象。这时怎么办呢？\n当当当~~可以用函数绑定作用域函数呀</p>\n<pre><code data-query="{}" data-lang="">function bind(fn,context){\n    return function(){\n        return fn.apply(context,arguments);\n    }\n}\n</code></pre>\n<p>用法：</p>\n<pre><code data-query="{}" data-lang="">var person1 = {\n    name: "claiyre",\n    sayName: function(){\n        alert(this.name);\n    }\n}\nvar sayPerson1Name = bind(person1.sayName,person1);\nsayPerson1Name();  //claiyre\n</code></pre>\n<p><code>call</code>函数和<code>apply</code>函数可以临时改变函数的作用域，使用bind函数可以得到一个绑定了作用域的函数</p>\n<h3 id="函数柯里化curry"><a href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96curry" aria-hidden="true"><span class="icon icon-link"></span></a>函数柯里化(curry)</h3>\n<p>curry的概念很简单：只传递部分参数来调用函数，然后让函数返回另一个函数去处理剩下的参数。可以理解为赋予了函数“加载”的能力。\n许多js库中都封装了curry函数，具体使用可以这样。</p>\n<pre><code data-query="{}" data-lang="">var match = curry(function(what,str){\n    return str.match(what)\n}); \n\nvar hasNumber = match(/[0-9]+/g);\nvar hasSpace = match(/\\s+/g)\n\nhasNumber("123asd");       //[\'123\']\nhasNumber("hello world!");  //null\n\nhasSpace("hello world!");  //[\' \'];\nhasSpace("hello");         //null\n\nconsole.log(match(/\\s+/g,\'i am  Claiyre\'));  //直接全部传参也可： [\' \',\'  \']\n</code></pre>\n<p>一旦函数经过柯里化，我们就可以先传递部分参数调用它，然后得到一个更具体的函数。这个更具体的函数通过闭包帮我们记住了第一次传递的参数，最后我们就可以用这个更具体的函数为所欲为啦~</p>\n<p>一个较为简单的实现curry的方式：</p>\n<pre><code data-query="{}" data-lang="">function curry(fn){\n    var i = 0;\n    var outer = Array.prototype.slice.call(arguments,1);\n    var len = fn.length;\n    return function(){\n        var inner = outer.concat(Array.prototype.slice.call(arguments));\n        return inner.length === len?fn.apply(null,inner):function (){\n                var finalArgs = inner.concat(Array.prototype.slice.call(arguments));\n                return fn.apply(null,finalArgs);\n            }\n    }\n}\n</code></pre>\n<h3 id="debounce函数"><a href="#debounce%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="icon icon-link"></span></a>debounce函数</h3>\n<p>debounce函数，又称“去抖函数”。它的功能也很简单直接，就是防止某一函数被连续调用，从而导致浏览器卡死或崩溃。用法如下：</p>\n<pre><code data-query="{}" data-lang="">var myFunc = debounce(function(){\n    //繁重、耗性能的操作\n}，250);\nwindow.addEventListener(\'resize\',myFunc);\n</code></pre>\n<p>像窗口的resize，这类可以以较高的速率触发的事件，非常适合用去抖函数，这时也可称作“函数节流”，避免给浏览器带来过大的性能负担。\n具体的实现时，当函数被调用时，不立即执行相应的语句，而是等待固定的时间w,若在w时间内，即等待还未结束时，函数又被调用了一次，则再等待w时间，重复上述过程，直到最后一次被调用后的w时间内该函数都没有被再调用，则执行相应的代码。\n实现代码如下：</p>\n<pre><code data-query="{}" data-lang="">function debounce(fn,wait){\n    var td;\n    return function(){\n        clearTimeout(td);\n        td= setTimeout(fn,wait);\n    }\n}\n</code></pre>\n<h3 id="once函数"><a href="#once%E5%87%BD%E6%95%B0" aria-hidden="true"><span class="icon icon-link"></span></a>once函数</h3>\n<p>顾名思义，once函数是仅仅会被执行一次的函数。具体实现如下：</p>\n<pre><code data-query="{}" data-lang="">function once(fn){\n    var result;\n    return function(){\n        if(fn){\n            result = fn(arguments);\n            fn = null;\n        }\n        return result;\n    }\n}\n\nvar init = once(function(){\n    //初始化操作\n})\n</code></pre>\n<p>在被执行过一次后,参数fn就被赋值null了，那么在接下来被调用时，便再也不会进入到if语句中了，也就是第一次被调用后，该函数永远不会被执行了。</p>\n<p>还可以对上述once函数进行改进，不仅可以传入函数，同时还可以给传入的函数绑定作用域u，同时实现了bind和once。</p>\n<pre><code data-query="{}" data-lang="">function once(fn,context){\n    var result;\n    return function(){\n        if(fn){\n            result = fn.apply(context,arguments);\n            fn = null;\n        }\n        return result;\n    }\n}\n</code></pre>\n<h1 id="结语"><a href="#%E7%BB%93%E8%AF%AD" aria-hidden="true"><span class="icon icon-link"></span></a>结语</h1>\n<p>通过以上的阅读，不难发现很多“高级函数”的实现其实并不复杂，数十行代码便可搞定，但重要的是能真正理解它们的原理，在实际中适时地应用，以此性能提升，让代码简洁，逻辑清晰</p>\n',extra:{}}}});