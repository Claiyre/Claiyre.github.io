webpackJsonp([10,20],{783:function(n,e){n.exports={content:'<div class="picidae-toc">\n<ul>\n<li>\n<a href="#%E5%89%8D%E8%A8%80">前言</a>\n</li>\n<li>\n<a href="#%E6%AD%A3%E6%96%87">正文</a>\n<ul>\n<li>\n<ul>\n<li>\n<a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a>\n</li>\n<li>\n<a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F">构造函数模式</a>\n</li>\n<li>\n<a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型模式</a>\n</li>\n<li>\n<a href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">组合使用构造函数和原型模式</a>\n</li>\n<li>\n<a href="#%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F">其他模式</a>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<a href="#%E7%BB%93%E8%AF%AD">结语</a>\n</li>\n</ul>\n</div>\n<blockquote>\n<p>博客原文地址：<a href="https://claiyre.github.io/">Claiyre的个人博客 https://claiyre.github.io/</a>\n博客园地址：<a href="http://www.cnblogs.com/nuannuan7362/">http://www.cnblogs.com/nuannuan7362/</a>\n如需转载，请在文章开头注明原文地址\n士不可以不弘毅，任重而道远。</p>\n</blockquote>\n<h1 id="前言"><a href="#%E5%89%8D%E8%A8%80" aria-hidden="true"><span class="icon icon-link"></span></a>前言</h1>\n<p>不管是哪门语言，千变万化不离其宗，深入理解其本质，方能应用自如。对应到js，闭包，原型，函数，对象等是需要花费大功夫思考、理解的。本文穿插了js原型和函数的相关知识，讨论了批量创建对象的几种方式以及它们的优缺点。</p>\n<!--more-->\n<h1 id="正文"><a href="#%E6%AD%A3%E6%96%87" aria-hidden="true"><span class="icon icon-link"></span></a>正文</h1>\n<p>说起创建对象，最容易想到的便是通过对象字面量方式直接定义一个对象吧，但这种方式只能创建少量，单独且相互间无联系的对象。若要批量创建对象，该如何？</p>\n<h3 id="工厂模式"><a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>工厂模式</h3>\n<p>工厂模式非常直观，将创建对象的过程抽象为一个函数，用函数封装以特定接口创建对象的细节。如下所示：</p>\n<pre><code data-query="{}" data-lang="">function createStudent(name,sex,grade){                     \n    var o = new Object();\n    o.name = name;\n    o.sex = sex;\n    o.grade = grade;\n\n    o.sayName = function(){\n        console.log(this.name);\n    }\n    return o;\n}\nvar s1 = createStudent(\'Claiyre\',\'famale\',1);\n</code></pre>\n<p>通俗地讲，工厂模式就是将创建对象的语句放在一个函数里，通过传入参数来创建特定对象，最后返回创建的对象。\n<strong>工厂模式虽然可以创建多个相似的对象，但却不能解决对象标识的问题，即怎样知道一个对象的类型</strong>。构造函数模式应运而生。</p>\n<h3 id="构造函数模式"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>构造函数模式</h3>\n<p>构造函数模式是java语言创建对象的通用方式。两种语言用构造函数创建对象的方式略有不同，注意区别。\n在JavaScript中没有类的概念，函数即为一等公民，因此，不必显式声明某个类，直接创建构造函数即可，类的方法和属性在构造函数中（或原型对象上）处理。构造函数模式的示例代码如下：</p>\n<pre><code data-query="{}" data-lang="">function Student(name,sex,grade){               \n    this.name = name;\n    this.sex = sex;\n    this.grade = grade;\n    this.sayName = function(){\n        console.log(this.name);\n    }\n}\nvar s2 = new Student(\'孙悟空\'，\'male\',2);\n</code></pre>\n<p>细心的朋友一定发现了构造函数的函数名首字母是大写的，而普通函数首字母则是小写，这是众多OO语言约定俗成的规定，虽然大多数情况下不大写也不会报错，但是为了代码的规范性和可读性，还是应该将构造函数的首字母大写，与普通函数区别开。\n与工厂模式相比，用构造模式创建对象有以下几点不同：</p>\n<ul>\n<li>没有显示地创建对象</li>\n<li>直接将属性和方法赋给this对象</li>\n<li>没有return语句</li>\n</ul>\n<p>此外，还应注意到要创建Student的实例，必须要使用new操作符，创建的实例对象将有一个constructor（构造器）属性，指向Person构造函数。调用构造函数创建对象经过了以下几个过程：</p>\n<ul>\n<li>创建一个新对象</li>\n<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li>\n<li>执行构造函数中的代码</li>\n<li>返回新对象（不需要显式返回）</li>\n</ul>\n<p>构造函数虽好用，但也不是没有缺点。使用构造函数的主要问题是：<strong>每个方法都要在每个实例上创建一遍</strong>。在ECMAScript中，函数即对象，因此每定义一个函数，也就是实例化了一个对象。下面的例子证明了这个缺点。</p>\n<pre><code data-query="{}" data-lang="">var s3 = new Student(\'唐僧\',\'male\',3);                   \nvar s4 = new Student(\'白骨精\',\'female\',4);\ns3.sayName();\ns4.sayName();\nconsole.log(s3.sayName == s4.sayName);\n</code></pre>\n<p>运行结果：\n<img src="http://p1.bpimg.com/567571/3359b736833b0818.png"></p>\n<p>也就是说通过构造函数实例化的多个对象的方法，是多个不同的方法，但它们内部的代码以及实现的功能是相同的，这就造成了一定的资源浪费。\n幸运的是，这个问题可以用原型模式来解决。</p>\n<h3 id="原型模式"><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>原型模式</h3>\n<p>js中，每个函数都有一个<code>prototype</code>属性，它是一个指针，指向一个对象，叫做原型对象，原型对象包含了<strong>可以由特定类型的所有实例对象共享的属性和方法</strong>。此外，这个对象有一个与生自来的属性<code>constructor</code>，指向创建对象的构造方法。\n使用原型模式可以让所有的实例共享原型对象中的属性和方法，也就是说，不必再构造函数中定义对象实例的信息。用代码表示如下：</p>\n<pre><code data-query="{}" data-lang="">function Student_1(){\n\n}\nStudent_1.prototype.name = \'Claiyre\';\nStudent_1.prototype.sex = \'female\';\nStudent_1.prototype.class = 5;\nStudent_1.prototype.sayName = function (){\n    console.log(this.name);\n}\n\nvar s5 = new Student_1();                              \ns5.sayName();    //Claiyre\nvar s6 = new Student_1();\ns6.sayName();    //Claiyre\n</code></pre>\n<p>一张图胜过千言万语，下图清楚地阐释了各个对象和原型对象间的关系：\n<img src="http://p1.bpimg.com/567571/1538bfc566a89b93.png"></p>\n<p>了解过原型后，可以继续在实例对象上增添属性或方法：</p>\n<pre><code data-query="{}" data-lang="">s6.name = \'John\';                             \ns6.sayName();       //John\n</code></pre>\n<p>当要读取某个对象的属性时，都会执行一次搜索，搜索首先从对象实例本身开始，如果在实例中找到了这个属性，则搜索结束，返回实例属性的值；若实例上没有找到，则继续向对象的原型对象延伸，搜索对象的原型对象，若在原型对象上找到了，则返回原型上相应属性的值，若没有找到，则返回<code>undefined</code>。因此，实例对象属性会覆盖原型对象上的同名属性，所以上面第二行代码输出的是John。</p>\n<ul>\n<li><code>Object.getPrototypeOf(object)</code>方法返回参数对象的原型对象。</li>\n<li><code>Object.keys(object)</code>方法返回对象上课枚举的实例属性。</li>\n</ul>\n<p>原型中的所有属性都是被所有实例所共享的，这种共享对于函数来说非常合适，对于包含基本值的属性也说的过去（实例属性会覆盖原型同名属性），但对于那些包含引用类型的属性，可有大麻烦了</p>\n<pre><code data-query="{}" data-lang="">Student_1.prototype.friends = [\'aa\',\'bb\'];              \n\nconsole.log(\'s6的朋友\' + s6.friends);\ns5.friends.push(\'cc\');\nconsole.log(\'s5的朋友\' + s5.friends);\nconsole.log(\'s6的朋友\' + s6.friends);\n</code></pre>\n<p>运行结果：\n<img src="http://i1.piimg.com/567571/a81173a51ef0b9d4.png"></p>\n<p>问题来了，我们只想改变s5的朋友列表，但由于原型模式的共享本质，s6的朋友列表也随之改变了。\n因此，很少单独使用原型模式。</p>\n<h3 id="组合使用构造函数和原型模式"><a href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>组合使用构造函数和原型模式</h3>\n<p>构造函数模式用于定义实例属性，原型模式则用于定义方法和共享的属性。这种混合模式不仅支持向构造函数传入参数，还最大限度地节约了内存，可谓是集两模式之长。示例代码如下：</p>\n<pre><code data-query="{}" data-lang="">function Student(name,sex,grade){                   \n    this.name = name;\n    this.sex = sex;\n    this.grade = grade;\n}\n\nStudent.prototype.sayName = function(){\n        console.log(this.name);\n}\nStudent.prototype.school = \'Joooh school\';\n</code></pre>\n<h3 id="其他模式"><a href="#%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>其他模式</h3>\n<p>除了以上几种常见的模式外，批量创建对象的方式还有</p>\n<ul>\n<li>动态原型模式：仅在第一次调用构造函数时，将方法赋给原型对象的相应属性，其他示例的处理方式同构造函数模式</li>\n<li>寄生构造函数模式：仅仅封装创建对象的代码，然后再返回新创建的对象，仍使用<code>new</code>操作符调用</li>\n<li>稳妥构造函数模式：没有公共属性，只有私有变量和方法，以及一些<code>get/set</code>方法，用以处理私有变量。</li>\n</ul>\n<h1 id="结语"><a href="#%E7%BB%93%E8%AF%AD" aria-hidden="true"><span class="icon icon-link"></span></a>结语</h1>\n<p>每种模式都有各自的优缺点，具体要使用哪种，还需结合实际场景，深入理解，灵活运用。</p>\n',extra:{}}}});